# はじめに

## 知的生産とはなにか

- 知識を用いて価値を生み出すこと
- 具体的には「執筆」や「プログラミング」など

## プログラミングはどうやって学ぶか

- 情報収集、モデル化、検証の繰り返し
  - 人が書いたブログやコードなどを読んで情報収集する
  - 収集した複数の情報から共通するパターンを見つけ出し、抽象化する
    - 書いたコードとプログラムの動作を照らし合わせ「こう書くとこう動くのではないか？」を見つけ出す
  - 仮説を元に、自分の実現したい結果から書くべきプログラムを逆算する
    - 実際に書いてみて、結果からのトライアンドエラーを繰り返す
    - 期待する動作と実際の動作のギャップを埋めていく

# 1章 新しいことを学ぶには

## サイクルを回す原動力：やる気

- 社会人は学生の頃と比べると学ぶことに対して強い逆風が吹いている
- 限られた時間やお金を学びに使っていくためには強い「やる気」が必要になってくる

- やる気を維持するには？
  - やる気は行動と報酬のサイクルによって維持される
  - すばやく報酬を得られることが大事

- ゴールは明確に
  - 新しいことを学ぼうと思った時、「学ぼうとしたことをマスターする」というのは目標の立て方のバッドパターン
  - 「マスターする」ではゴールがどこにあるかわからないので、どうしたら「マスターした」実感が得られるのかが不明瞭
  - 達成考えられない目標に対してのやる気を維持するのは困難

- チュートリアルはゴールを近くする
  - チュートリアルは「情報が与えられる」「実践的な課題が与えられる」「与えられた情報を元に課題が達成される」という一連の流れが短い時間で繰り返される
  - 短期的に達成感を得られることで、やる気を保ちながら学ぶことができる

> **目標設定をする時に気をつけること「SMART criteria」**
> - Specific: 改善を行う具体的な領域が明確である
> - Measurale: 量、もしくは少なくとも進捗がわかる指標がある（計測可能）
> - Assignable: 誰が計画の実行をするのかが明確である
> - Realistic: 現実的に達成可能である、実現に必要なリソースが得られる
> - Time-related: いつ結果が得られるかが明確である

### 紙の参考書を選ぶコツ

- 多くの大学はシラバスを公開していて、そこに参考図書が書かれている
  - 学部1年生向けは去年まで高校生だった人を対象としているので、前提知識が少なくても読めるものが選ばれていることが多い
  - ただし、著書が講師本人だったり師弟関係や同じ大学の同僚のものであるものはその限りではない
  - 複数の大学で選ばれていると安心

- 正誤表が充実している
  - 紙の本はミスがあってもすぐには修正できないため、正誤表を公開しておき、次の版を出す時に修正される
  - 出版社のWebサイトには本毎の公式ページがあり、正誤表があるはず
  - 正誤表がない本は最初から完璧だったか著者に改善していく気がないかのどちらかであることが多い

- 改定されている/ロングセラーである
  - 改訂版が出ることは組版をやり直すほどの大幅な情報の追加/修正があった証拠
  - 組版のやり直しコストを掛けてまで改訂すると出版社が判断した証拠
  - ベストセラーは多くの人が買った本だが、短期的に集中して買われたものには注意が必要

## 情報収集の3つの方法

### 知りたいところから

- 遅延評価勉強法
  - 達成したいことへの目的を分割して、目的に必要なところから断片的にやっていく
  - 断片的に集めた情報が後から繋がっていくという勉強法

- YAGNI原則
  - YAGNI(You Aren't Gonna Need It)原則とは「必要になるまで機能を追加してはいけない」というもの
  - 必要になりそうだから実装するのではなく、本当に必要になってから実装するという考え方
    - 今考えないといけないことは「今どうあるべきか」なのに「将来こうかもしれない」と考えるのはミッションから気を散らしている
    - 時間は貴重だ
    - 実際に必要にならなかったら、その実装に使った時間と、それを読む人の時間と、その実装が占める空庵が無駄になる
  - Matzのソースコードの読み方
    - 「全体を読もうとしない」
      - ソースコードには「物語」はないので、面白そうなところをつまみ食いして先人の知恵を学べればそれで十分
    - 「目的を持って読む」
      - 何かを学ぼうと思ってソースコードを読めば、効果的に読解して知識が得られる

### 知りたいところから学ぶための前提条件

- 目的が明確化されている
  - 「勉強する」は不明確
  - 「Rubyをマスターする」も不明確
  - 「Rubyの処理系をソースコードからビルドする」は明確
- 目標が達成可能である
  - あなた自身にとって適切な目標である必要がある
  - いきなり「すごいゲームを作る」では目標の具体的な達成方法がわかりにくい
  - 「ゲームパッドのボタンを押すと背景色が変わる」などの具体的な近い目標を定める必要がある
- 大まかに全体像を把握している
  - 目的が明確、辿り着けそうな目標がある以外に、必要な情報を見つけるためにどこを探せばよいのか分かる必要がある
  - プログラミングの各種ライブラリについて全ての関数名を知る必要はない
  - どこにその情報がまとまっているかを把握し、必要な時にWebサイトなどを開いて眺めればよい
  - 大まかな全体像を把握すればよい

### 大雑把に

- 全体像を詳細に把握している必要はない「大まかに」把握していればよい
- 必要なものを探そうとした時に「確かあのあたりにあった気がする」と絞り込むことが出来ればよい

- ソースコードを段階的に読む
  - 内部構造を解説したドキュメントがあればそれを読む
  - ディレクトリ構造を読む
  - ファイル構造を読む
  - 略語を調査する
  - データ構造を知る
  - 関数同士の呼び出し関係を把握する
  - 関数を読む

### 片っ端から

- 大雑把に情報収集が出来ない場合、片っ端からやるしかない
- 大雑把な全体像の把握ができない状態は理解の組み立てをするための材料が足りていない状態
- 大まかな説明を読んでも頭の中でイメージが沸かない場合、イメージするための知識がそもそも欠けている
- 「何から学べば効率がいいか」を判断する材料を手に入れることから始める

- 写経というテクニック
  - 既に出来上がったプログラムを書き写すこと
  - 何も考えずに書き写すのではなく「あれ、これ前にも出てきたな」「いつものパターンに似ているけどちょっと違う」などを考えながら行う事が大事
  - 手を動かしながら類似点や相違点を発見していくことで自分の中でモデル化する
  - 「なぜこうなっているんだろう」「ここをこう書き換えたらどうなるだろう」と考え、自分の中に落とし込む

- 時間を区切ろう
  - 本1冊などを写経するととても時間がかかる
  - やる気を保つためにも時間を区切る

- 写経は補助輪
  - 時間を書けることが目的ではなく、自分で前に進めるようになるまでがゴール
  - 自分が必要ないと感じたタイミングで辞めてよい

## 抽象とはなにか

### 抽象・abstruct

- 抽象とは「具体的な対象から、注目すべき重要な部分だけを抜き出す」こと

### モデル・模型

- モデル/模型は現実世界の仕組みを説明するための簡素化された表現
  - 子供が遊ぶ車の模型は現実の車とイコールではない
  - 「車を走らせて遊ぶ」という目的を達成する上では重要な部分だけを抜き出して作られている
- モデルの価値は現実との一致度ではなく、現実を直接操作することに比べてどれくらい低コストになるかである
- 抽象化出来ていると、トラブルに対して「こういう処理のあたりに問題があるのではないか」を予想することができる

### モジュール

- ソフトウェア開発においては物理的な局在が必要ない
  - 歯車を組み合わせて何かを作るときは物理的に歯車が接触して作用する
  - プログラムのソースコードは隣接している行だけでなく遠くの行に対しても作用する事がある

- 相互作用を制限する
  - モジュールは「関連の強いコードをグループにしてまとめたもの」
    - モジュールの中にある構成要素については明示的にexportしなければ外から参照できない
    - モジュールはモジュールの外の構成要素について明示的にimportしなければ参照できない

### モデル・ビュー・コントロー

- ボタンが押された回数をカウントするプログラムがあったとしたら
  - モデルは押された回数の整数値
  - ビューは押された回数を画面に表示するためのコード
  - コントローラはボタンが押された時に整数値を書き換えるコード

### なぜ抽象化が必要か

- パターンの発見による一般化
  - いくつかある問題の解法から「この手の問題はこうすれば解ける」と考えたり、ハトやスズメやツバメが飛ぶのを見て「鳥は飛ぶものだ」と考えるのがパターンの発見
  - 「鳥は飛ぶものだ」という抽象的な知識は間違っているかもしれない
  - しかし「飛ぶかもしれない」と自分で考えることはできる
  - これにより、遭遇した新しい問題にも抽象化した知識から対処することができる

## どうやって抽象化するか

### 比較して学ぶ

- 「同じ」と「違う」の間に注目
  - 「同じ」と「違う」の二極化ではない
  - 実際はグラデーションになっている
    - 「完全に同じ」
    - 「とても良く似ていて大部分同じだけど少しだけ違うもの」
    - 「ほとんど似ていないけども少しだけ共通部分のあるもの」
    - 「完全に違うもの」
  - 電動ドリルの例え
    - 先端の工具部分が交換できるようになっている
    - 先端部分は同じではないけれど、根元部分は回転する部分に差し込んで使えるように同じ構造になっている
   - プログラミングの「インターフェース」という概念と同じ
     - 「クラスがどのようなメソッドを持っているか」
     - ドリルの例えでは「交換可能な部品はつなぎ目に共通化されている」というパターンがあると考えられる

### 歴史から学ぶ

- 過去の出来事の中に現在進行中の出来事と似た構造のものがあるかもしれない
- ここから共通のパターンを見つけて次に何が起こりそうかを予想することができる
- 変更前と変更後を比較して、同変わったのか、なぜ変わったのかを考えることで理解が深まる
- プログラムは人工物なので「作る前はどうだったのか」「今とどう違うのか」を考えることで「なぜそれを作ったのかが見えてくる」

### パターン本から学ぶ

- 一見合理的だが、あなたの具体的な経験を元にパターンを見出す手助けになることしかできない
- 具体的な経験がないと「ピンとこない」「抽象的でよくわからない」となる
- 自分の中でパターン化出来ているか確認する
  - 自分の言葉で説明できるか
  - 自分の経験に基づいた具体例を挙げることができるか
  - 自分の目的を達成するためにその知識を使えるか
- 公開鍵暗号と南京錠のたとえ
  - 「公開鍵暗号は南京錠のようなもの」を丸覚えすることはできる
  - 「公開鍵暗号は◯◯◯のようなもの」という問題を解くこともできる
  - しかしそれだけでは「なぜ似ているのか」を自分の言葉で説明したり、別の例に変えたり、
  自分の解決したい問題が公開鍵暗号によって解決できると気づいて応用することはできない

## 検証

何かをわかった気になっても本当にわかっているという保証にはならない。
脳内のモデルを実際に使い、結果を観察して検証しなければならない。

### 作って検証

- プログラミングの学習はプログラムを書いて実行して自分の理解が多々敷くなければすぐエラーになるので検証しやすい
- プログラミングの間違いの多くはエラーメッセージが教えてくれる

- 解説も作ることの一種
  - なにか学んだのであれば「1日前の自分にどう説明するか？」などを考えてブログの解説記事を書いたりするのもよい
  - 相手に正しく伝わらなかった場合や見当違いの質問が来た場合はうまく説明できていないということなので、改善のサイクルを回せる

### 試験で検証

- 資格試験などで知識が身についているかの検証ができる

# 2章 やる気を出すには

## やる気が出ない人の65%はタスクを一つに絞れてない

- やる気が出ないと悩んでいる人のうち65%の人が今やろうとしていることが複数だと答えた
- なれた作業でない限り複数のタスクを一度に実行するのはとても難しい
- 複数のタスクを並行で実行することは「タスクの切り替えの意思決定」という追加のタスクを抱えることになる
- まずはやることを一つに絞って進めるのがよい

### 絞るためにまず全体像を把握しよう

- まずはタスクを全部書き出して、全部でどれくらいあるのか、どんなタスクがあるのかを把握する

### Getting Things Done: まずすべて集める

- まず「気になること」を全部1箇所に集める
  - 人間はたくさんのことを一度に覚えておくことが出来ない
  - 覚えていられる以上のことを覚えていようとすると負担からストレスが生まれて認知能力が低下する
  - まずは「やるべきことはすべてここに集まっている」という状態を作り「やるべきことを覚えていかないといけない」というストレスから自分を開放する
  - GTDでは「やること」ではなく「気になること」を集める
  - 「ToDoかどうか」の判断を後回しする
  - 「集める」と「考える」のタスクを一度にしないため

### 全部集めて、その後で処理する

- まずは全部集める
  - 全部集めた後に「これは何か？」「自分はこれに対して行動を起こす必要があるか？」を問う
  - 「行動を起こす必要がある」と思ったら次は「どういう結果を求めているのか？」を問う
  - そして「ついに取るべき具体的な行動は？」を問う
  - ここでようやく「ToDo」の形になる
- 次に取るべき行動とは
  - 「行動を起こす必要がないもの」をゴミ・資料・保留の3つに分類する
  - 「次に取るべき具体的な行動」が複数なら「プロジェクト」にする
  - 「次に取るべき具体的な行動」が2分以内でできるなら、今やる
  - 「次に取るべき具体的な行動」をやるのが自分でないなら、他人に任せて連絡待ちリストに入れる
  - 「次に取るべき具体的な行動」をやるのが特定後二時なら、カレンダーに書く
  - どれにも当てはまらなかったものが「次に取るべき行動」のリストに入る

### どうやってタスクを1つ選ぶのか

- 緊急度がつけられなければ箱の上から1つづつ順番にやる
- まず「今日やること」から順番にやっていくなど
- 「今日やること」が実際には今日中に終わらないのであれば「本当に今日中にやらなければならないこと」だけをピックアップする
- 「本当に今日やらないといけないこと」が今日できる以上の量になっているのであれば、納期を変えるか、仕様を変えるか、やめるしかない

### 緊急性分解論

- 今日やらなければいけないことが今日できる量を越えている「緊急事態」にどう対処するか
  - 質を下げられないか？
  - 量を減らせないか？
  - 納期を延ばせないか？
  - 方法を変えられないか？
  - 別のもので代替できないか？
  - お金で解決できないか？
  - どうしようもないならやめるべき

## 「優先順位付け」はそれ自体が難しいタスク

- 「今日やらないといけないタスク」がない場合、タスクリストの沢山のタスクの中からどれを選んで実行したらよいか
- 優先度は本当につけるべきなのか？少し掘り下げてみる

### 1次元でないと大小比較ができない

- タスクには依存関係が複雑に絡み合っている
- そのため事前に優先順位をつけることは困難

### 不確定要素がある場合の大小関係は？

- リスクと価値と優先順位
- Mike Cohnは「アジャイルな見積もりと計画づくり」で製品昨日の優先順位付けの判断基準として以下を提案した
  - 金銭価値
  - コスト
  - 新しい知識
  - リスク

### 重要事項を優先する

- 何を優先すべきかについてよく言及されるのが「重要事項を優先する」という考え方
- 「緊急」とは「すぐに対応しなければいけないように見えるもの」
- 「重要」とは「あなたのミッション、価値観、優先順位の高い目標の達成に結びついているもの」

- 「通知された」は「緊急」ではない
  - 「通知された」時、まず「これは自分にとって重要なのか？」を考える
  - 「すぐやらないと忘れてしまうかもしれない」という不安感からやっていた作業を投げ出して着手しがちだが、分けて考える

- 価値観はボトムアップに言語化する
  - 人生の目標・価値観
  - 3〜5年後の構想
  - 1〜2年後の目標
  - 注意を向けるべき分野・責任を負っていること
  - 現在のプロジェクト
  - 現在の行動

### 7つの習慣

成長のプロセスには、依存状態から自立状態へと変わる「私的成功」と自立状態から相互依存状態へ変わる「公的成功」の2つがある。

- 私的成功を支えるもの
  - 主体性を発揮する
  - 目的を持って始める
  - 重要事項を優先する
- 公的成功を支えるもの
  - Win-Winを考える
  - 理解してから理解される
  - 相乗効果を発揮する
- これに「刃を研ぐ」を加えたものが7つの習慣

### 優先順位を今決めようとしなくてよい

- 優先順位付けは思っているほど簡単ではない
  - 数が多いと大変
  - 評価軸が複数あったりする
  - 不確実性があったりする

## 1つのタスクのやる気を出す

### タスクが大きすぎる

- タスクが大きすぎてゴールが遠い、タスクの大きさが見積もれていないせいで漠然と大きそうなことが腰を重くする
- 4時間で終えられるかどうかが一つの目安

- 執筆という大きなタスク
  - 「1章ごとに締め切りを設定する」などして分割する
  - 例えば「アイディアをメモして付箋を作る」「付箋を並び替えて構成を考える」「構成を元に原稿に起こす」というフェーズに分割する

### タイムボックス

- タスクを小さくする一つの方法として「時間で切る」がある
- 「決まったサイズ（時間）の箱にタスクを入れる」というイメージ
- 「ある分野についての情報収集をする」や「プレゼン資料をブラッシュアップする」などのタスクは終了条件が明確ではないので時間で切る分割方法が適している

- 集中力の限界
  - 人間の集中力を持続できる時間には限界がある
  - ゴールが見えないとなにかに逃避して集中が続かなくなってしまうため、短い時間で区切り、見えるところにゴールを設置する

- ポモドーロテクニック
  - 今日一日分のタスクリストを作る
  - タスクの大きさをポモドーロの個数で見積もる
  - 1ポモドーロの間はタスクの変更をせずに1つのことに集中する
  - もし自分または他人による割り込みが発生したらそれを記録する
  - 1ポモドーロ集中した状態を継続できたら、立ち上がって数歩歩くなどして視点を切り替える

- 見積もり能力を鍛える
  - 見積もり能力は、見積もり、実行し、実際に掛かった時間と見積もりを比較し、ズレの理由を考えることで徐々に鍛えられる
  - 各タスクが何ポモドーロでできるのか
    - 1ポモドーロでできそうなタスクの量を見積もる
    - 実際にやってみる
    - ズレを観察する
    - 1ポモドーロで終わると思ったものが終わらなかったり、逆に早く終わったり樋受け券の積み重ねで徐々に精度を上げていく
  - 1日で何ポモドーロできるのか
    - 実際に毎日やってみる
    - 「1日の稼働時間を1ポモドーロ分で割って算出する」はよくある誤解
    - 1ポモドーロ25分としても、人間は25分間の集中を連続して行うことが出来ないため

- 計測し、退け、まとめる
  - 成果を上げるものは、仕事でも計画からでもなく、時間が何に取られているかを明らかにするところからスタートする
  - 次に、時間に対する非生産的な要求を退ける
  - 最後に、得られた自由になる時間を大きくまとめる
  - 時間を記録する、整理する、まとめるという三段階のプロセスが成果を上げるための時間管理の基本

# 3章 記憶を鍛えるには

脳の記憶の仕組みはコンピュータでファイルを保存するのとは違い、筋育のトレーニングのように繰り返すことが必要。
また、単位繰り返すだけでなく、定期的なテストをしたほうが良い。

# 4章 効率的に読むには

- 理解力がボトルネックになっている人にとっては、速く読むことは重要ではない
  - 遅く読むと理解度は高くなるが、おそすぎると単位時間に読める範囲が狭くなる
  - 得たい理解度で読める最適な時間を自分で見つけて調整していく

- 読書ノートに書きながら読む
  - わからないことは何でも記録する
  - 何度も出現する単語を記録する
  - 概念の間の関係や理由と結論の関係などを矢印でつなぐ

- わからないことを解消するために読む
 - 用語の理解が不十分
 - 論理の筋道の理解が不十分
 - 問題意識の理解が不十分
 - 図解する必要がある

- 「わかる」の定義
  - 「なぜろうなるのか？」という質問に答えられること
  - 「本に書いてあるから」や「先生がそう言うから」ではだめ
  - 自分お言葉でなぜそうなるのかを説明できなければ、わかったことにはならない。
  - 本で自分の知らない定理や定義が使われている場合、それも調べなければならない

- 人に教える
  - 人に教えるための資料を作ることは自分辞任の記憶を強化することにもつながる
  - 実際に教えなくても、資料を作るだけで効果はある

# 5章 考えをまとめるには

## 情報が多すぎる？少なすぎる？

### 書き出し法で情報量を確認

まずは5分間でレポートで言及すると良さそうな情報を思いつく限り書き出してみる

- 質を求めてはいけない
  - この段階で質を求めてはいけない
  - 実際に書くかどうかは気にせず、書くかもしれないことを書き出す

## 多すぎる情報をどうまとめるか

### 並べて一覧性を高くする

- 付箋に書いてみて、机の上などに並べてみる

### 関係の有りそうなものを近くに移動

- 並べた付箋の関係がありそうなものを近くに並べてまとめる
- これを繰り返すことで徐々にグループができる
- KJ法を試してみる

# 6章 アイデアを思い付くには
