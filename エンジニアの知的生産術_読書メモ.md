# はじめに

## 知的生産とはなにか

- 知識を用いて価値を生み出すこと
- 具体的には「執筆」や「プログラミング」など

## プログラミングはどうやって学ぶか

- 情報収集、モデル化、検証の繰り返し
  - 人が書いたブログやコードなどを読んで情報収集する
  - 収集した複数の情報から共通するパターンを見つけ出し、抽象化する
    - 書いたコードとプログラムの動作を照らし合わせ「こう書くとこう動くのではないか？」を見つけ出す
  - 仮説を元に、自分の実現したい結果から書くべきプログラムを逆算する
    - 実際に書いてみて、結果からのトライアンドエラーを繰り返す
    - 期待する動作と実際の動作のギャップを埋めていく

# 1章 新しいことを学ぶには

## サイクルを回す原動力：やる気

- 社会人は学生の頃と比べると学ぶことに対して強い逆風が吹いている
- 限られた時間やお金を学びに使っていくためには強い「やる気」が必要になってくる

- やる気を維持するには？
  - やる気は行動と報酬のサイクルによって維持される
  - すばやく報酬を得られることが大事

- ゴールは明確に
  - 新しいことを学ぼうと思った時、「学ぼうとしたことをマスターする」というのは目標の立て方のバッドパターン
  - 「マスターする」ではゴールがどこにあるかわからないので、どうしたら「マスターした」実感が得られるのかが不明瞭
  - 達成考えられない目標に対してのやる気を維持するのは困難

- チュートリアルはゴールを近くする
  - チュートリアルは「情報が与えられる」「実践的な課題が与えられる」「与えられた情報を元に課題が達成される」という一連の流れが短い時間で繰り返される
  - 短期的に達成感を得られることで、やる気を保ちながら学ぶことができる

> **目標設定をする時に気をつけること「SMART criteria」**
> - Specific: 改善を行う具体的な領域が明確である
> - Measurale: 量、もしくは少なくとも進捗がわかる指標がある（計測可能）
> - Assignable: 誰が計画の実行をするのかが明確である
> - Realistic: 現実的に達成可能である、実現に必要なリソースが得られる
> - Time-related: いつ結果が得られるかが明確である

### 紙の参考書を選ぶコツ

- 多くの大学はシラバスを公開していて、そこに参考図書が書かれている
  - 学部1年生向けは去年まで高校生だった人を対象としているので、前提知識が少なくても読めるものが選ばれていることが多い
  - ただし、著書が講師本人だったり師弟関係や同じ大学の同僚のものであるものはその限りではない
  - 複数の大学で選ばれていると安心

- 正誤表が充実している
  - 紙の本はミスがあってもすぐには修正できないため、正誤表を公開しておき、次の版を出す時に修正される
  - 出版社のWebサイトには本毎の公式ページがあり、正誤表があるはず
  - 正誤表がない本は最初から完璧だったか著者に改善していく気がないかのどちらかであることが多い

- 改定されている/ロングセラーである
  - 改訂版が出ることは組版をやり直すほどの大幅な情報の追加/修正があった証拠
  - 組版のやり直しコストを掛けてまで改訂すると出版社が判断した証拠
  - ベストセラーは多くの人が買った本だが、短期的に集中して買われたものには注意が必要

## 情報収集の3つの方法

### 知りたいところから

- 遅延評価勉強法
  - 達成したいことへの目的を分割して、目的に必要なところから断片的にやっていく
  - 断片的に集めた情報が後から繋がっていくという勉強法

- YAGNI原則
  - YAGNI(You Aren't Gonna Need It)原則とは「必要になるまで機能を追加してはいけない」というもの
  - 必要になりそうだから実装するのではなく、本当に必要になってから実装するという考え方
    - 今考えないといけないことは「今どうあるべきか」なのに「将来こうかもしれない」と考えるのはミッションから気を散らしている
    - 時間は貴重だ
    - 実際に必要にならなかったら、その実装に使った時間と、それを読む人の時間と、その実装が占める空庵が無駄になる
  - Matzのソースコードの読み方
    - 「全体を読もうとしない」
      - ソースコードには「物語」はないので、面白そうなところをつまみ食いして先人の知恵を学べればそれで十分
    - 「目的を持って読む」
      - 何かを学ぼうと思ってソースコードを読めば、効果的に読解して知識が得られる

### 知りたいところから学ぶための前提条件

- 目的が明確化されている
  - 「勉強する」は不明確
  - 「Rubyをマスターする」も不明確
  - 「Rubyの処理系をソースコードからビルドする」は明確
- 目標が達成可能である
  - あなた自身にとって適切な目標である必要がある
  - いきなり「すごいゲームを作る」では目標の具体的な達成方法がわかりにくい
  - 「ゲームパッドのボタンを押すと背景色が変わる」などの具体的な近い目標を定める必要がある
- 大まかに全体像を把握している
  - 目的が明確、辿り着けそうな目標がある以外に、必要な情報を見つけるためにどこを探せばよいのか分かる必要がある
  - プログラミングの各種ライブラリについて全ての関数名を知る必要はない
  - どこにその情報がまとまっているかを把握し、必要な時にWebサイトなどを開いて眺めればよい
  - 大まかな全体像を把握すればよい

### 大雑把に

- 全体像を詳細に把握している必要はない「大まかに」把握していればよい
- 必要なものを探そうとした時に「確かあのあたりにあった気がする」と絞り込むことが出来ればよい

- ソースコードを段階的に読む
  - 内部構造を解説したドキュメントがあればそれを読む
  - ディレクトリ構造を読む
  - ファイル構造を読む
  - 略語を調査する
  - データ構造を知る
  - 関数同士の呼び出し関係を把握する
  - 関数を読む

### 片っ端から

- 大雑把に情報収集が出来ない場合、片っ端からやるしかない
- 大雑把な全体像の把握ができない状態は理解の組み立てをするための材料が足りていない状態
- 大まかな説明を読んでも頭の中でイメージが沸かない場合、イメージするための知識がそもそも欠けている
- 「何から学べば効率がいいか」を判断する材料を手に入れることから始める

- 写経というテクニック
  - 既に出来上がったプログラムを書き写すこと
  - 何も考えずに書き写すのではなく「あれ、これ前にも出てきたな」「いつものパターンに似ているけどちょっと違う」などを考えながら行う事が大事
  - 手を動かしながら類似点や相違点を発見していくことで自分の中でモデル化する
  - 「なぜこうなっているんだろう」「ここをこう書き換えたらどうなるだろう」と考え、自分の中に落とし込む

- 時間を区切ろう
  - 本1冊などを写経するととても時間がかかる
  - やる気を保つためにも時間を区切る

- 写経は補助輪
  - 時間を書けることが目的ではなく、自分で前に進めるようになるまでがゴール
  - 自分が必要ないと感じたタイミングで辞めてよい

## 抽象とはなにか

### 抽象・abstruct

- 抽象とは「具体的な対象から、注目すべき重要な部分だけを抜き出す」こと

### モデル・模型

- モデル/模型は現実世界の仕組みを説明するための簡素化された表現
  - 子供が遊ぶ車の模型は現実の車とイコールではない
  - 「車を走らせて遊ぶ」という目的を達成する上では重要な部分だけを抜き出して作られている
- モデルの価値は現実との一致度ではなく、現実を直接操作することに比べてどれくらい低コストになるかである
- 抽象化出来ていると、トラブルに対して「こういう処理のあたりに問題があるのではないか」を予想することができる

### モジュール

- ソフトウェア開発においては物理的な局在が必要ない
  - 歯車を組み合わせて何かを作るときは物理的に歯車が接触して作用する
  - プログラムのソースコードは隣接している行だけでなく遠くの行に対しても作用する事がある

- 相互作用を制限する
  - モジュールは「関連の強いコードをグループにしてまとめたもの」
    - モジュールの中にある構成要素については明示的にexportしなければ外から参照できない
    - モジュールはモジュールの外の構成要素について明示的にimportしなければ参照できない

### モデル・ビュー・コントロー

- ボタンが押された回数をカウントするプログラムがあったとしたら
  - モデルは押された回数の整数値
  - ビューは押された回数を画面に表示するためのコード
  - コントローラはボタンが押された時に整数値を書き換えるコード

### なぜ抽象化が必要か

- パターンの発見による一般化
  - いくつかある問題の解法から「この手の問題はこうすれば解ける」と考えたり、ハトやスズメやツバメが飛ぶのを見て「鳥は飛ぶものだ」と考えるのがパターンの発見
  - 「鳥は飛ぶものだ」という抽象的な知識は間違っているかもしれない
  - しかし「飛ぶかもしれない」と自分で考えることはできる
  - これにより、遭遇した新しい問題にも抽象化した知識から対処することができる

## どうやって抽象化するか

### 比較して学ぶ

- 「同じ」と「違う」の間に注目
  - 「同じ」と「違う」の二極化ではない
  - 実際はグラデーションになっている
    - 「完全に同じ」
    - 「とても良く似ていて大部分同じだけど少しだけ違うもの」
    - 「ほとんど似ていないけども少しだけ共通部分のあるもの」
    - 「完全に違うもの」
  - 電動ドリルの例え
    - 先端の工具部分が交換できるようになっている
    - 先端部分は同じではないけれど、根元部分は回転する部分に差し込んで使えるように同じ構造になっている
   - プログラミングの「インターフェース」という概念と同じ
     - 「クラスがどのようなメソッドを持っているか」
     - ドリルの例えでは「交換可能な部品はつなぎ目に共通化されている」というパターンがあると考えられる

### 歴史から学ぶ

- 過去の出来事の中に現在進行中の出来事と似た構造のものがあるかもしれない
- ここから共通のパターンを見つけて次に何が起こりそうかを予想することができる
- 変更前と変更後を比較して、同変わったのか、なぜ変わったのかを考えることで理解が深まる
- プログラムは人工物なので「作る前はどうだったのか」「今とどう違うのか」を考えることで「なぜそれを作ったのかが見えてくる」

### パターン本から学ぶ

- 一見合理的だが、あなたの具体的な経験を元にパターンを見出す手助けになることしかできない
- 具体的な経験がないと「ピンとこない」「抽象的でよくわからない」となる
- 自分の中でパターン化出来ているか確認する
  - 自分の言葉で説明できるか
  - 自分の経験に基づいた具体例を挙げることができるか
  - 自分の目的を達成するためにその知識を使えるか
- 公開鍵暗号と南京錠のたとえ
  - 「公開鍵暗号は南京錠のようなもの」を丸覚えすることはできる
  - 「公開鍵暗号は◯◯◯のようなもの」という問題を解くこともできる
  - しかしそれだけでは「なぜ似ているのか」を自分の言葉で説明したり、別の例に変えたり、
  自分の解決したい問題が公開鍵暗号によって解決できると気づいて応用することはできない

## 検証

何かをわかった気になっても本当にわかっているという保証にはならない。
脳内のモデルを実際に使い、結果を観察して検証しなければならない。

### 作って検証

- プログラミングの学習はプログラムを書いて実行して自分の理解が多々敷くなければすぐエラーになるので検証しやすい
- プログラミングの間違いの多くはエラーメッセージが教えてくれる

- 解説も作ることの一種
  - なにか学んだのであれば「1日前の自分にどう説明するか？」などを考えてブログの解説記事を書いたりするのもよい
  - 相手に正しく伝わらなかった場合や見当違いの質問が来た場合はうまく説明できていないということなので、改善のサイクルを回せる

### 試験で検証

- 資格試験などで知識が身についているかの検証ができる

# 2章 やる気を出すには
